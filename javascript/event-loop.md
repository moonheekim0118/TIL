## 요약

자바스크립트 자체는 싱글스레드 언어이다.
즉, 호출 스택을 하나만 사용 할수 있다.
이는 결국 동시에 하나의 일만 처리 할 수 있다는 뜻이다.
그런데 어떻게 비동기 요청을 지원할까?

자바스크립트 엔진은 한번에 하나의 작업밖에 처리하지 못하지만, 브라우저는 웹 api, 이벤트루프, 콜백큐와 같은 것들을 가지고 있다.
웹 api 의 메서들은 작동을 마치면, 콜백 함수를 콜백 큐에 집어넣는다.
거기서 콜백함수들이 실행을 대기한다. 콜백큐는 다른 말로 태스크큐라고도 한다.
자바스크립트 엔진 자체는 싱글스레드이지만,
자바스크립트가 구동되는 환경인 웹 브라우저에서는 여러개의 스레드가 사용된다.
정확히 말하자면 web apis 가 멀티스레드.
그리고 자바스크립트 엔진이 이것들 (web apis )과 상호작용하기 위한 도구가 이벤트루프와 콜백 큐이다.

## 📍 싱글 스레드 & 비동기

- 자바스크립트는 한 번에 하나의 태스크만 실행할 수 있는 **싱글 스레드 (Single Thread)** 방식으로 동작한다.

- 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에, 이를 동기 처리(현재 실행 중인 태스크가 종료 할 때 까지 다음에 실행될 태스크가 대기하는 방식)한다면 처리 시간이 걸리는 태스크 실행의 경우 블로킹(작업중단)이 발생한다.
- 따라서 자바스크립트는 현재 실행 중인 태스크가 종료되지 않은 상태에도 다음 태스크를 곧바로 실행하는 **비동기 처리 방식**을 따른다.

- 싱글 스레드 방식은 한 번에 하나의 태스크만 처리 할 수 있는데 브라우저의 동작을 보면 많은 태스크가 동시에 처리되는 것 처럼 느껴진다. HTTP 요청을 통해 서버로부터 데이터를 가져오면서 동시에 렌더링하기도 하는 것 처럼 말이다. 이처럼 **싱글 스레드 언어인 자바스크립트의 동시성(concurrency)을 지원하는 것이 바로 이벤트 루프**이다.

<br/>
<br/>

## 📍 자바스크립트 엔진

구글의 V8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분된다.

### 콜 스택 (Call Stack)

- 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고, 제거되는 스택 자료구조이다.

### 힙 (Heap)

- 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 잠조한다.

- 메모리에 값을 저장하려면 값을 저장할 메모리 공간의 크기를 결정해야한다. 객체는 원시 값과 다르게 크기가 정해져 있지 않으므로, 할당될 메모리 공간의 크기를 런타임에서 동적 할당 해야한다. 따라서 객체가 저장되는 메모리 공간인 힙은** 구조화 되어있지 않다.**

즉, 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행한다. **비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저/Node.js가 담당**한다.

<br/>
<br/>

## 📍 브라우저 환경 구성요소

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EA%B5%AC%EC%A1%B0.jpg)

`Web API` - 우리가 비동기 호출을 위해 사용하는 Ajax나 Timer들은 모두 Web API 영역에 정의되어 있다. <br/>

`매크로태스크 큐와 마이크로태스크 큐` - 자바스크립트 실행환경은 두가지의 큐를 가지고 있으며 각각 태스크의 종류에 따라 다른 큐에 담기게 된다. 아래에서 더 자세히 알아보도록 하겠다. <br/>

`이벤트 루프` - 자바스크립트 엔진과 그 실행 환경(브라우저, Node.js)을 연동시켜주는 장치이다. 태스크 큐 or 마이크로 태스크 큐에 담겨있는 콜백 함수와 자바스크립트 엔진의 콜 스택을 연동 시켜준다. 아래에서 더 자세히 알아보도록 하겠다. <br/>

<br/>
<br/>

## 📍 매크로태스크 큐와 마이크로태스크 큐

태스크 큐에 담기는 것은 종류에 따라서 각각 다른 큐에 담기게 된다.

### 매크로태스크 큐

- setTimeout() , setInterval(), UI 렌더링, requestAnimationFrame() 을 담는다.

### 마이크로태스크 큐

- Promise, MutationObserver 를 담는다.

<br/>

✔️ **마이크로태스크 큐에 들어간 태스크는 이벤트 핸들러나 렌더링 작업 혹은 다른 매크로태스크 큐에 들어간 태스크가 실행되기 전에 처리된다.**

<br/>
<br/>

## 📍 이벤트 루프의 동작 과정

- 이벤트 루프는 태스크가 들어오길 기다렸다가, 태스크가 들어오면 이를 처리하고*(이 때 자바스크립트 엔진이 활성화 된다)*, 처리할 태스크가 없는 경우에는 동작하지 않는다.

- 만약 지금 하고 있는 일이 있는데 새로운 태스크가 또 들어왔다면 새로 들어온 태스크를 매크로태스크 큐 혹은 마이크로태스크 큐에 넣고, **자바스크립트가 아무것도 하지 않을 때 (콜 스택이 비었을 때) 가 되면 해당 태스크를 처리**한다.

<br/>

### 자바스크립트 엔진을 활성화 하는 대표적인 태스크

1. 외부 스크립트가 로드 되었을 때, 해당 스크립트를 실행 한다. `<script src="">`
2. 사용자가 마우스를 움직였을 때 `mouseover` 이벤트와 이벤트 핸들러를 실행한다.
3. setTimeout 에서 설정한 시간이 다 된 경우, 콜백 함수를 실행한다.
   - 정확히 setTimeout은 코드 내에서 호출되면 Web API에서 타이머를 실시하고 설정된 시간이 다 되면 , 태스크 큐에 들어간다.

<br/>

### 예시를 통해 보는 동작 과정

![](https://github.com/moonheekim0118/frontend-blog/blob/master/content/blog/JavaScript/images/%EC%8B%A4%ED%96%89%20%EA%B2%B0%EA%B3%BC.png?raw=true)
<br/>

먼저 결과물을 보면 동기 요청 `console.log('Call Stack')` 이 가장 먼저 실행되고, 비동기 요청 중 마이크로태스크 큐에 들어가는 `Proimise~` 절이 실행된다. 그리고 마지막으로 태스크 큐에 들어가는 비동기 요청인 `setTimeout` 이 실행됨을 알 수 있다. <br/>

아래 그림을 통해 더 자세히 알아보도록 하겠다. <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%840.jpg)
<br/>

가장 먼저 스크립트가 로드 될때 `스크립트 실행`이라는 태스크가 먼저 매크로태스크 큐에 들어간다. 이 때 콜스택에는 이미 **글로벌 실행 컨텍스트**가 생성되어 있는 상태이고, 이 때 **스크립트 실행 이라는 태스크를 실행하게 됨으로써 글로벌 실행 컨텍스트 내에 있는 코드가 실행된다.** <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%841.jpg)
<br/>

1. 이벤트루프에 의해서 매크로태스크 큐에 들어가있던 스크립트 실행 태스크가 실행처리 된다. <br/>

2. 글로벌 실행 컨텍스트의 가장 처음에 있는 코드를 읽어서 콜스택에 담는다. <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%842.jpg)
<br/>

setTimeout은 Web API에서 제공하는 함수이므로 Web API 내에서 타이머를 실행한다. 그 사이에 컨텍스트 내 다음 코드를 읽고 콜스택에 담는다. <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%843.jpg)
<br/>

Web API에서 타이머가 종료되면 setTimeout 비동기 요청을 매크로태스크 큐에 담는다. 직전에 콜스택에 들어온 Promise.resolve 코드는 마이크로태스크 큐에 담는다. <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%844.jpg)
<br/>

이 사이에 컨텍스트 내 다음 코드를 읽어서 콜스택에 담는다. 이번 코드는 비동기 요청이 아니므로 콜스택에서 나와서 바로 처리를 해준다. 따라서 결과창에 "Call Stack" 이 찍힌다. <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%845.jpg)
<br/>

1. 이제 콜스택이 비었으므로 이벤트 루프가 마이크로태스크 큐와 매크로태스크 큐에 있는 실행 완료된 콜백함수를 순서대로 콜스택에 담아줄 차례이다.

2. 먼저 마이크로태스크 큐에 있는 코드를 콜스택에 담아준다.

3. 콜스택에서 나와서 바로 처리를 해준다. 따라서 결과창에 "Microtask Queue"가 찍힌다.

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%846.jpg)
<br/>

1. 이제 또 콜스택이 비었고, 마이크로태스크 큐에 있는 작업까지 모두 마쳤으니 이벤트 루프가 매크로태스크 큐에 남아있는 실행 완료된 콜백함수를 콜스택에 담아줄 차례이다.

2. 매크로태스크 큐에 있는 코드를 콜스택에 담아준다.

3. 콜스택에서 나와서 바로 처리를 해준다. 따라서 결과창에 "Macrotask Queue"가 찍힌다 <br/>

![](https://github.com/moonheekim0118/frontend-blog/raw/master/content/blog/JavaScript/images/%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A3%A8%ED%94%847.jpg)
<br/>

글로벌 실행 컨텍스트 내부에 있는 코드를 모두 실행하고 나서 콜스택과 태스크 큐들은 비어지게 되고, 이벤트 루프는 다음 작업을 기다리는 상태로 들어간다. <br/>

<br/>
