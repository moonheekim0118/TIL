# Stale-While-Revalidate

- 개발자가 캐시된 컨텐츠를 즉시 로드하는 즉시성과 캐시된 컨텐츠에 대한 업데이트가 샹후외 사용되도록 보장하는 최신성간의 균형을 유지한다.
- 만약 캐시가 stale 할 경우(신선하지 않을 경우) 캐싱된 응답의 재검증 요청을 수행할지, 서버에 요청을 보내 새 응답을 받을지 결정한다.
- 지정된 시간 이내에 요청이 반복되면 오래된 캐싱 응답을 반환하고, 백그라운드에 재검증 요청을 보내 캐싱된 응답을 최신으로 갱신하고, max-age를 비교할 때 사용되는 최신성 타이머를 재설정한다.
- 이후 요청에서는 서버에 요청을 보내서 새 응답을 반환하고, 캐싱한다.
- 즉!!!!! 재검증 하는 동안은 stale 한 컨텐츠를 보여준다!! 말그대로 `Stale-While-Revalidate` 이다!

## 메커니즘 보기

```js
// HTTP Response Cache-Control Header
Cache-Control: max-age=1, stale-while-revalidate=59
```

1. 0~1 초에 요청이 반복되는 경우 캐싱된 응답이 최신 상태이므로, 재검증 없이 캐싱된 응답이 그대로 사용된다. **(Max age가 1초이므로)**
2. 1~60초에 요청이 반복되는 경우, 캐싱된 응답이 오래된 상태이지만, 캐싱된 응답을 사용한다. 동시에 다음 요청 때 최신 응답데이터가 사용 될 수 있도록, 백그라운드에서 재검증 요청을 수행하여 최신 응답으로 갱신한다. **(max-age는 1초라서 넘어서 stale 하구, State-while-revalidate이 59초이므로!!)**
3. 60초 이상 지난 후 요청이 반복되는 경우, 캐싱된 응답을 사용하지 않는다. 서버에 요청을 보내 새로운 응답을 사용하고 캐싱한다.
